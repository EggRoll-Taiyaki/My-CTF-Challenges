# Tychophobia

Your mission, should you choose to accept it, is to break the RNG.

**Author. EggRoll** 

## Overview

We introduce a brand new random number generator (RNG) based on linear congruence generator (LCG). LCG is processed as usual, the output is then split into two parts, upper bits (U) and lower bits (L). These two numbers are fed into a 13-round alternating Feistel. Finally, this RNG returns the first output only. Our task is to recover the initial seed of LCG according to 2023 outputs of the RNG

## Special Case. Identity Permutation

The challenge is quite scary, so let's simplify the challenge first. Consider that the secret permutation is just identity, then the output is simply the XOR of U and L. 

### Key Observation

Look the parameters carefully, the modulus is a power of $2$, which is suspicious. Why such number is bad? That's because the output of LCG is partially determined by partial input. For convenience, we use $x_{k}$ to represent the residue of $x$ divided by $2^{k}$. Recall the following well-known fact: $$\alpha \equiv \beta \pmod{mn} \longrightarrow \alpha \equiv \beta \pmod{n}$$ We have $$((ax+b)_{128})_{k} = (ax+b)_{k} = (ax_{k}+b)_{k}, \quad \forall k \le 128 $$ Or equivalently, the lower bits of outputs are fully determined given initial lower bits. 

### Truncated LCG

Now, we brute-force all the possibilities of initial lower $l$ bits of LCG. From the results generated by RNG, all the lower $l$ bits of $U$s is revealed. Notice that they could in fact be treated as higher $l$ bits. Therefore, we are able to find the initial $L$ by solving truncated LCG. Since the problem is well-studied, I would left two references instead of explaining further.

[Stack Overflow - Problem with LLL reduction on truncated LCG schemes](https://crypto.stackexchange.com/questions/37836/problem-with-lll-reduction-on-truncated-lcg-schemes)
[Cryptanalysis of Pseudorandom Generators, UCSD](https://cseweb.ucsd.edu/classes/fa17/cse206A-a/LecPRG.pdf)

```python
def solve_LCG(a, m, approx):

	n = len(approx)
	M = Matrix(ZZ, n, n)
	for i in range(1, n):
		M[i, i] = -1
		M[i, 0] = a**i
	M[0, 0] = m
	
	L = M.LLL()

	v = vector([x for x in approx])
	lower_bits = L.solve_right(vector([round(RR(x)/m) * m - x for x in L * v]))

	return list(v + lower_bits)
```

## General Case. Arbitrary Permutation

To make our previous approach be successful, we should identify which things we actually require. In order to reduce the challenge to truncated LCG, we hope to have at least the XOR of $U_{l}$ and $L_{l}$. Although $U, L$ are passed to the annoying Feistel, we can still extract $U_{l} \oplus L_{l}$ if the round permutation fixes the last $l$ elements. 

### Lazy Permuation Generation

From the source code, the $i$-th permutation is simply a power of the secret permutation $P$, say $P^{i}$. So here is our question. When does $P^{i}$ fix the last $l$ elements? The answer is if and only if the lengths of the cycles containing the last $l$ elements are divisors of $i$. Denote the LCM of those lengths by $c$. To solving truncated LCG, it requires enough high bits (entropy).

### Experiment

Thus, we are going to estimate the following value.

:::warning
The probability that $c$ is small. 
:::

```python
def perm(L, p):
    return [L[p[i]] for i in range(len(L))]

k = 64
cnt = 0
for _ in range(10000):
    p = Permutations(list(range(k))).random_element() # random permutation
    id = p.copy()

    for i in range(1, 120):
        if (id[-8:] == [56, 57, 58, 59, 60, 61, 62, 63]):
            cnt += 1
            break
        id = perm(id, p)
print(cnt)
```

It turns out the value is about $0.25$, which is large enough!!!

### Verfication

Now we come to the last issue, how do we check the revealed number is indeed the initial seed? There may be various approaches I think, feel free to discuss with me. Here is mine: For each output from RNG, the bit count should have same parity to that of reconstructed $U \oplus L$.

```python
for i in range(2023):
	state = a * state % m
			
	if bin((state >> k) ^^ (state % mmm)).count("1") % 2 != bin(out[i]).count("1") % 2:
		check = False
		break
```

### [Optional] Speed-Up

There are two possible ways to accelerate the process
1. Assume we are going to test $c=1 \sim 2m$, it suffices to test $c=m+1 \sim 2m$
2. As we mentioned before, the lower bits are already determined. So we could substract those terms and shorten the size of truncated LCG. 

Weeeeee! Time to get the flag!

:::success
idek{ps3ud0_r4nd0mn3ss_h01ds_n0_f34rs_f0r_y0u}
:::
